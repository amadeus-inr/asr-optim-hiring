## Problem description 
You are the director of Clever and Very Complex Machines (or short: CVCM), a company producing advanced machinery using even more advanced machinery. 

The old production machinery has broken down, so you need to buy new production machines for the company. Your goal is to make as much money as possible during the restructuring period. 

During this period you will be able to buy and sell machines and operate them for profit while CVCM owns them. Due to space restrictions, CVCM can own at most one machine at a time. 

During the restructuring period, there will be several machines for sale. Being an expert in the advanced machines market, you already know the price `P_i` and the availability day `D_i` for each machines `M_i` . 
Note that if you do not buy machine `M_i` on day `D_i` then somebody else will buy it and it will not be available later. 
Needless to say, you cannot buy a machine if CVCM has less money than the price of the machine. If you buy a machine `M_i` on day `D_i` then CVCM can operate it starting on day `D_i` + 1. 
Each day that the machine operates, it produces a profit of `G_i` dollars for the company.

You may decide to sell a machine to reclaim a part of its purchase price any day after you’ve bought it.
Each machine has a resale price `R_i` for which it may be resold to the market. You cannot operate a machine on the day that you sell it, but you may sell a machine and use the proceeds to buy a new machine on the same day. Once the restructuring period ends, CVCM will sell any machine that it still owns. 

Your task is to maximize the amount of money that CVCM makes during the restructuring.

## Input

The input consists of several test cases. Each test case starts with a line containing three positive
integers N , C , and D . 

- N is the number of machines for sale (N ≤ 100), 
- C is the number of dollars with which the company begins the restructuring (C ≤ 100), 
- and D is the number of days that the restructuring lasts ( D ≤ 100).

Each of the next N lines describes a single machine for sale. Each line contains four integers:

- `D_i` : the day on which the machine is for sale
- `P_i` : the dollar price for which it may be bought
- `R_i` : the dollar price for which it may be resold
- `G_i` : the daily profit generated by operating the machine

These numbers satisfy the following conditions:

- 1 ≤ `D_i` ≤ D
- 1 ≤ `R_i` < `P_i` ≤ 100
- 1 ≤ `G_i` ≤ 100

The last test case is followed by a line containing three zeros.

## Output

For each test case, display its case number followed by the largest number of dollars that CVCM can
have at the end of day D + 1 . Follow the format of the sample output.

Example Input | Example Output
-|-
6 10 20 | Case 1: 44

## TODO 

- [ ] Please fork this repository
- [ ] Please write an algorithm to solve [this instance](https://github.com/amadeus-inr/asr-optim-hiring/blob/master/instance.txt) 
- [ ] Please do not use optimization solvers (e.g. Cplex) and implement your own algorithm
- [ ] Please share yourcode on your fork with a small description how to run it against the proposed instance.
- [ ] Please desscribe in a short document your analysis of the problem and an assessment of your solution

It is preferable that you write this algorithm using JAVA. It is OK if you want to use another programming language e.g. C++.

There are different ways to solve the problem highlighted above and the solution you come up with will tell us a lot about your skill as a developer and your ability to solve optimization problems.


## Presentation of the repository
This repository is implemented in C++. You don’t need any dependencies.
Arborescence of repository:
- main.cpp: Reading of the instances and execution of the algorithm.
- debug.h: Only for debugging. To activate warnings and errors, uncomment line 4. 
- Algorithms: Contains the algorithm skeleton. There is currently only one algorithm, branchAndCut.
- DataStructures: Folder containing the 3 classes I coded for this algorithm: machine, instance, and solution.

## How to execute this repo
### Building
```
cmake ..
cd build
make
```
### Executing
```
./solveAsrHiring
```
### Debugging
For debugging, you can activate warnings and errors. To this end, please uncomment line 4 in debug.h and rebuild.

## How I solved this problem
### Steps of reflection
This problem could easily be solved by an optimization solver but I had to implement my own algorithm. I wanted to explore 2 possibilities:
- First, some heuristics. This problem could be solved by a simulated annealing or some genetic algorithm, and the vector of chosen machines could be a great datastructure to be used for crossing or destroy/repair algorithms. At first, I began to explore in that direction, as I assumed the testing could be on very big instances (up to 100 days, 100 machines, and 100 dollars).
- Secondly, some exact solving algorithms. I immediatly thought abound a branching algorithm. That is what I implemented, to test my functions. As I saw it was very quich on given instances, I did not pursue the (more complicated) heuristic approach.

### Algorithm mechanism: branch and cut
The main idea about branching is that, as the space of solution is restricted (for your instances, at most $$2^6$$ possibilities), we can explore it. The condition is that we can determine the maximizing criterion quickly - here, the final profit.
So, we begin by ordering the machines by day of purchase and we can them one by one.
Then, recursively, we compute the final profit of the solution with and without this machine. At each step, if the solution is acceptable, we memorize it if it is best than the best known final profit.
A solution is not acceptable whenever the amount of money at a certain day is negative.
We can cut a branch (i.e not explore further the branch) whenever a solution is not acceptable. When it is, we know that even by buying another machine later, the solution is never going to be acceptable. So we don’t have to explore this branch further.
The algorithm memorizes the best final profit and returns it when it has finished exploring the search space.

### To go further
To go further with this problem, I could have implemented an heuristic such as genetic algorithm or simulated annealing. For the instances given, it is not necessary as an exact algorithm provides a good solution quickly. However, it could be interesting for bigger instances.
I began implementing a simulated annealing before realizing it would not be useful.

Thank you for considering my application for this role. I hope I have been clear in my explanations, and I hope we will be in contact soon.
Sincerely, Anne-Lise